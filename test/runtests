#!/bin/bash

# Author: Daniel Kahn Gillmor <dkg@fifthhorseman.net>

set -e

tests="${1##t-}"

if [ -n "${TEST_LOCK}" ]; then
    TEST_LOCK="$(realpath ${TEST_LOCK})"
    flock_cmd="flock -w 10 ${TEST_LOCK}"
fi

BADVARS=0
for v in APACHECTL TEST_HOST TEST_IP TEST_PORT TEST_QUERY_DELAY TEST_GAP MSVA_PORT; do
    if [ ! -v "$v" ]; then
        printf "You need to set the %s environment variable\n" "$v" >&2
        BADVARS=1
    fi
done

if [ 0 != "$BADVARS" ]; then
    exit 1
fi

function stop_msva() {
    kill %1
}

# Compare expected/actual outputs, filtering out headers from actual
# output that are expected to change between runs or builds (currently
# "Date" and "Server"). The headers must be excluded in the expected
# output.
#
# Parameters:
# $1: path to expected output
# $2: path to actual output
# $3: additional options for diff (optional)
function diff_output_filter_headers()
{
    local expected="$1"
    local actual="$2"
    diff $3 -u "${expected}" <( cat "${actual}" | \
	grep -v -P '^Date:\s.*GMT\s?$' | \
	grep -v -P '^Server:\sApache'  | \
	tail -n "$(wc -l < ${expected})" )
}

# Run a command, storing its PID in the given file
# Usage: run_with_pidfile PIDFILE COMMAND [ARGS]
function run_with_pidfile()
{
    local pidfile=$1
    local cmd=$2
    shift 2
    echo $BASHPID >${pidfile}
    exec ${cmd} $*
}

# Kills the process with the PID contained in a given file, then
# deletes the file.
# Usage: kill_by_pidfile PIDFILE
function kill_by_pidfile()
{
    local pidfile="${1}"
    # In some testcases with expected failure, gnutls-cli sometimes
    # failed before the subshell in front of the pipe (see gnutls-cli
    # call below) got so far as to write the PID, much less exec
    # sleep. So we need to check if there actually is anything to
    # kill.
    if [ -n "${pidfile}" ]; then
	local pid=$(cat "${pidfile}")
	if [ -n "${pid}" ] && ps -p "${pid}"; then
	    kill "${pid}"
	fi
	rm "${pidfile}"
    fi
}

function apache_down_err() {
    printf "FAILURE: %s\n" "$TEST_NAME"
    ${APACHECTL} -f "${t}/apache.conf" -k stop || true
    if [ -e output ]; then
	printf "\ngnutls-cli outputs:\n"
	diff_output_filter_headers "output" "$output" || true
    fi

    if [ -n "${sleep_pidfile}" ]; then
	kill_by_pidfile "${sleep_pidfile}"
    fi

    local errlog="logs/${TEST_NAME}.error.log"
    if [ -r "${errlog}" ]; then
	printf "\nApache error logs:\n"
	tail "${errlog}"
    fi

    if [ -n "${USE_MSVA}" ]; then
	stop_msva
    fi
}

if [ -z "$tests" ] ; then
    tests=${srcdir}/tests/*
else
    tests=${srcdir}/tests/"$(printf "%02d" "$tests")"_*
fi

if [ -n "${USE_MSVA}" ]; then
    GNUPGHOME=msva.gnupghome MSVA_KEYSERVER_POLICY=never monkeysphere-validation-agent &
    trap stop_msva EXIT

    sleep "$TEST_GAP"

    printf "TESTING: initial MSVA verification\n"
    MONKEYSPHERE_VALIDATION_AGENT_SOCKET="http://127.0.0.1:$MSVA_PORT" msva-query-agent https "$(cat client.uid)" x509pem client < client/x509.pem
    printf "\nSUCCESS: initial MSVA verification\n"
fi

for t in $tests; do
    if [ -z "${flock_cmd}" ]; then
	echo "Warning: no lock file set"
	sleep "$TEST_GAP"
    fi
    t="$(realpath ${t})"
    export srcdir="$(realpath ${srcdir})"
    export TEST_NAME="$(basename "$t")"
    output="outputs/${TEST_NAME}.output"
    rm -f "$output"

    if [ -e ${t}/fail.* ]; then
        EXPECTED_FAILURE="$(printf " (expected: %s)" fail.*)"
    else
        unset EXPECTED_FAILURE
    fi
    printf "TESTING: %s%s\n" "$TEST_NAME" "$EXPECTED_FAILURE"
    trap apache_down_err EXIT
    if [ -n "${USE_MSVA}" ]; then
	MONKEYSPHERE_VALIDATION_AGENT_SOCKET="http://127.0.0.1:$MSVA_PORT" \
	    ${flock_cmd} \
	    ${APACHECTL} -f "${t}/apache.conf" -k start \
	    || [ -e "${t}/fail.server" ]
    else
	${flock_cmd} \
	    ${APACHECTL} -f "${t}/apache.conf" -k start \
	    || [ -e "${t}/fail.server" ]
    fi

    # PID file for sleep command (explanation below)
    sleep_pidfile="$(mktemp mod_gnutls_test-XXXXXX.pid)"

    # The sleep call keeps the pipe from the subshell to gnutls-cli
    # open. Without it gnutls-cli would terminate as soon as sed is
    # done, and not wait for a response from the server, leading to
    # failing tests. Sending sleep to the background allows the test
    # case to proceed instead of waiting for it to return. The sleep
    # process is stopped after gnutls-cli terminates.
    if (sed "s/__HOSTNAME__/${TEST_HOST}/" <${t}/input && \
	run_with_pidfile "${sleep_pidfile}" sleep "${TEST_QUERY_DELAY}" &) | \
	gnutls-cli -p "${TEST_PORT}" $(cat ${t}/gnutls-cli.args) "${TEST_HOST}" \
	>"$output";
    then
        if [ -e ${t}/fail* ]; then
            printf "%s should have failed but succeeded\n" "$(basename "$t")" >&2
            exit 1
        fi
    else
        if [ ! -e ${t}/fail* ]; then
            printf "%s should have succeeded but failed\n" "$(basename "$t")" >&2
            exit 1
        fi
    fi

    kill_by_pidfile "${sleep_pidfile}"
    unset sleep_pidfile

    if [ -e ${t}/output ] ; then
	diff_output_filter_headers "${t}/output" "$output" "-q"
    fi
    if [ -n "${USE_MSVA}" ]; then
	trap stop_msva EXIT
    else
	trap - EXIT
    fi
    ${APACHECTL} -f "${t}/apache.conf" -k stop || [ -e ${t}/fail.server ]
    printf "SUCCESS: %s\n" "$TEST_NAME"
done

if [ -n "${USE_MSVA}" ]; then
    stop_msva
fi
